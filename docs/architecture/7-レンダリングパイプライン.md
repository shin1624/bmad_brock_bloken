# 7. レンダリングパイプライン

## 7.1 レンダリング最適化
```typescript
class RenderingSystem {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private offscreenCanvas: OffscreenCanvas;
  private offscreenCtx: OffscreenCanvasRenderingContext2D;
  
  render(entities: Entity[], deltaTime: number): void {
    // ダブルバッファリング
    this.clearOffscreen();
    
    // レイヤー別レンダリング
    this.renderBackground();
    this.renderEntities(entities);
    this.renderEffects();
    this.renderUI();
    
    // 画面に転送
    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
  }
  
  private renderEntities(entities: Entity[]): void {
    // フラスタムカリング
    const visibleEntities = entities.filter(e => 
      this.isInViewport(e.position, e.bounds)
    );
    
    // Zオーダーソート
    visibleEntities.sort((a, b) => a.zIndex - b.zIndex);
    
    // バッチレンダリング
    visibleEntities.forEach(entity => {
      entity.render(this.offscreenCtx);
    });
  }
}
```

## 7.2 パフォーマンス最適化
```typescript
// オブジェクトプール
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;
  private reset: (obj: T) => void;
  
  constructor(factory: () => T, reset: (obj: T) => void, size: number) {
    this.factory = factory;
    this.reset = reset;
    
    // 事前割り当て
    for (let i = 0; i < size; i++) {
      this.pool.push(factory());
    }
  }
  
  get(): T {
    return this.pool.pop() || this.factory();
  }
  
  release(obj: T): void {
    this.reset(obj);
    this.pool.push(obj);
  }
}

// 使用例：パーティクルプール
const particlePool = new ObjectPool(
  () => new Particle(),
  (p) => p.reset(),
  1000
);
```
