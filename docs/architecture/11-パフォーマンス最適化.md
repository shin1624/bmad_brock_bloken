# 11. パフォーマンス最適化

## 11.1 最適化テクニック
```typescript
// 1. RequestAnimationFrame最適化
class GameLoop {
  private lastTime = 0;
  private accumulator = 0;
  private readonly FIXED_TIMESTEP = 1000 / 60; // 60 FPS
  
  start(): void {
    requestAnimationFrame(this.loop.bind(this));
  }
  
  private loop(currentTime: number): void {
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    this.accumulator += deltaTime;
    
    // 固定タイムステップ
    while (this.accumulator >= this.FIXED_TIMESTEP) {
      this.update(this.FIXED_TIMESTEP);
      this.accumulator -= this.FIXED_TIMESTEP;
    }
    
    // 補間レンダリング
    const alpha = this.accumulator / this.FIXED_TIMESTEP;
    this.render(alpha);
    
    requestAnimationFrame(this.loop.bind(this));
  }
}

// 2. 空間分割による衝突検出最適化
class SpatialHash {
  private grid: Map<string, Set<Entity>>;
  private cellSize: number;
  
  constructor(cellSize: number) {
    this.grid = new Map();
    this.cellSize = cellSize;
  }
  
  insert(entity: Entity): void {
    const cells = this.getCells(entity);
    cells.forEach(cell => {
      if (!this.grid.has(cell)) {
        this.grid.set(cell, new Set());
      }
      this.grid.get(cell)!.add(entity);
    });
  }
  
  getNearby(entity: Entity): Entity[] {
    const cells = this.getCells(entity);
    const nearby = new Set<Entity>();
    
    cells.forEach(cell => {
      const entities = this.grid.get(cell);
      if (entities) {
        entities.forEach(e => {
          if (e !== entity) nearby.add(e);
        });
      }
    });
    
    return Array.from(nearby);
  }
  
  private getCells(entity: Entity): string[] {
    // エンティティが占めるセルを計算
    const minX = Math.floor(entity.bounds.left / this.cellSize);
    const maxX = Math.floor(entity.bounds.right / this.cellSize);
    const minY = Math.floor(entity.bounds.top / this.cellSize);
    const maxY = Math.floor(entity.bounds.bottom / this.cellSize);
    
    const cells: string[] = [];
    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        cells.push(`${x},${y}`);
      }
    }
    return cells;
  }
}
```

## 11.2 メモリ管理
```typescript
// WeakMapによる自動メモリ管理
class EntityCache {
  private cache = new WeakMap<Entity, CachedData>();
  
  set(entity: Entity, data: CachedData): void {
    this.cache.set(entity, data);
  }
  
  get(entity: Entity): CachedData | undefined {
    return this.cache.get(entity);
  }
}

// メモリリーク防止
class ResourceManager {
  private resources = new Map<string, Resource>();
  private refCounts = new Map<string, number>();
  
  load(id: string, resource: Resource): void {
    this.resources.set(id, resource);
    this.refCounts.set(id, 0);
  }
  
  acquire(id: string): Resource | undefined {
    const resource = this.resources.get(id);
    if (resource) {
      const count = this.refCounts.get(id) || 0;
      this.refCounts.set(id, count + 1);
    }
    return resource;
  }
  
  release(id: string): void {
    const count = this.refCounts.get(id);
    if (count !== undefined && count > 0) {
      this.refCounts.set(id, count - 1);
      if (count - 1 === 0) {
        // リソースを解放
        this.resources.delete(id);
        this.refCounts.delete(id);
      }
    }
  }
}
```
