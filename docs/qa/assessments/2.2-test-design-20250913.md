# Test Design: Story 2.2

Date: 2025-09-13
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 24
- Unit tests: 14 (58%)
- Integration tests: 7 (29%)
- E2E tests: 3 (13%)
- Priority distribution: P0: 9, P1: 10, P2: 4, P3: 1

## Test Scenarios by Acceptance Criteria

### AC1: 速度ベクトル（vx, vy）による移動

#### Scenarios

| ID           | Level       | Priority | Test                              | Justification                   |
| ------------ | ----------- | -------- | --------------------------------- | ------------------------------- |
| 2.2-UNIT-001 | Unit        | P0       | Vector2D速度計算精度              | 純粋な数学計算ロジック          |
| 2.2-UNIT-002 | Unit        | P0       | 位置更新計算 (position += velocity) | コア物理演算アルゴリズム        |
| 2.2-UNIT-003 | Unit        | P1       | deltaTime正規化処理               | フレームレート独立性確保        |
| 2.2-INT-001  | Integration | P0       | Ball Entityの移動統合             | Entity-Systemアーキテクチャ検証 |
| 2.2-E2E-001  | E2E         | P1       | 実際のボール移動視覚確認          | エンドユーザー体験検証          |

### AC2: 壁（上、左、右）との反射計算

#### Scenarios

| ID           | Level       | Priority | Test                          | Justification                  |
| ------------ | ----------- | -------- | ----------------------------- | ------------------------------ |
| 2.2-UNIT-004 | Unit        | P0       | 壁反射角度計算（入射角=反射角）| 物理法則の数学的実装検証       |
| 2.2-UNIT-005 | Unit        | P0       | 各壁（上・左・右）個別反射    | 境界条件での正確性             |
| 2.2-UNIT-006 | Unit        | P1       | 角度境界値テスト（0°-360°）   | 特殊角度での動作安定性         |
| 2.2-INT-002  | Integration | P0       | PhysicsSystem壁衝突統合       | システム間連携検証             |
| 2.2-E2E-002  | E2E         | P1       | 壁反射の視覚的一貫性          | プレイヤー体験での物理感覚     |

### AC3: パドルとの角度付き反射（打つ位置で反射角変化）

#### Scenarios

| ID           | Level       | Priority | Test                               | Justification                      |
| ------------ | ----------- | -------- | ---------------------------------- | ---------------------------------- |
| 2.2-UNIT-007 | Unit        | P0       | Circle-Rectangle衝突検出           | 衝突判定アルゴリズムの正確性       |
| 2.2-UNIT-008 | Unit        | P0       | パドル位置による角度計算（-75°~+75°）| ゲームプレイ核心メカニクス         |
| 2.2-UNIT-009 | Unit        | P1       | パドル端部での極端角度テスト       | 境界条件での予測可能性             |
| 2.2-INT-003  | Integration | P0       | Ball-Paddle衝突統合テスト          | 複雑なゲームオブジェクト間相互作用 |
| 2.2-INT-004  | Integration | P1       | 角度変化のEventBus配信             | イベント駆動アーキテクチャ検証     |

### AC4: 重力オプション（上級モード用、デフォルトOFF）

#### Scenarios

| ID           | Level       | Priority | Test                          | Justification                  |
| ------------ | ----------- | -------- | ----------------------------- | ------------------------------ |
| 2.2-UNIT-010 | Unit        | P2       | 重力加速度計算（9.8px/frame²）| 物理シミュレーション精度       |
| 2.2-UNIT-011 | Unit        | P2       | 重力ON/OFF切り替え            | 設定機能の確実性               |
| 2.2-INT-005  | Integration | P2       | 重力設定のUI連携              | 設定システム統合               |
| 2.2-E2E-003  | E2E         | P3       | 重力モード実際のゲームプレイ  | 上級ユーザー体験               |

### AC5: 速度上限/下限の設定（最小3px/frame、最大15px/frame）

#### Scenarios

| ID           | Level       | Priority | Test                           | Justification                 |
| ------------ | ----------- | -------- | ------------------------------ | ----------------------------- |
| 2.2-UNIT-012 | Unit        | P0       | 速度制限境界値テスト           | ゲーム制約の確実な実装        |
| 2.2-UNIT-013 | Unit        | P1       | 速度増加処理（ブロック破壊時2%）| ゲーム進行メカニクス          |
| 2.2-UNIT-014 | Unit        | P1       | 速度正規化処理                 | 数値安定性確保                |
| 2.2-INT-006  | Integration | P1       | 速度制限のシステム全体適用     | 物理システム一貫性            |
| 2.2-INT-007  | Integration | P1       | スコアシステムとの速度連携     | ゲームシステム間統合          |

## Risk Coverage Mapping

### High Risk Tests (PERF-001 & TECH-001)

**Performance Risk Mitigation**:
- 2.2-INT-001: Ball Entity移動パフォーマンス測定
- 2.2-INT-002: PhysicsSystem処理負荷測定
- 2.2-E2E-001/002: 60FPS維持確認

**Collision Detection Risk Mitigation**:
- 2.2-UNIT-007: 高精度衝突検出アルゴリズム
- 2.2-UNIT-008: 角度計算精度検証
- 2.2-INT-003: 高速移動時の貫通防止テスト

### Medium Risk Tests (TECH-002 & TECH-003)

**Numerical Precision Risk**:
- 2.2-UNIT-001/002: Vector2D計算精度
- 2.2-UNIT-004/005: 反射角度数学的精度

**React-Canvas Sync Risk**:
- 2.2-INT-001: Entity状態とUI同期
- 2.2-E2E-001: 視覚的一貫性確認

## Detailed Test Scenarios

### P0 Priority Tests (Critical Path)

#### 2.2-UNIT-001: Vector2D速度計算精度
```typescript
describe('Ball Vector2D Velocity Calculations', () => {
  test('should calculate position update with deterministic precision', () => {
    const ball = new Ball({ x: 100, y: 100 });
    ball.velocity = new Vector2D(5, -3);
    ball.update(16.67); // 60FPS frame
    
    expect(ball.position.x).toBeCloseTo(105, 2);
    expect(ball.position.y).toBeCloseTo(97, 2);
  });
});
```

#### 2.2-UNIT-004: 壁反射角度計算
```typescript
describe('Wall Reflection Physics', () => {
  test('should reflect off top wall with correct angle', () => {
    const physics = new PhysicsSystem();
    const velocity = new Vector2D(5, -3);
    const reflected = physics.reflectOffWall(velocity, 'top');
    
    expect(reflected.x).toBe(5);   // x unchanged
    expect(reflected.y).toBe(3);   // y inverted
  });
});
```

#### 2.2-UNIT-007: Circle-Rectangle衝突検出
```typescript
describe('Ball-Paddle Collision Detection', () => {
  test('should detect collision when ball intersects paddle', () => {
    const ball = { position: { x: 100, y: 180 }, radius: 8 };
    const paddle = { x: 90, y: 180, width: 100, height: 20 };
    
    const collision = CollisionDetection.circleRectangle(ball, paddle);
    expect(collision.detected).toBe(true);
    expect(collision.angle).toBeCloseTo(-45, 1);
  });
});
```

#### 2.2-UNIT-008: パドル位置による角度計算
```typescript
describe('Paddle Position-Based Angle Calculation', () => {
  test('should calculate reflection angle based on hit position', () => {
    const paddle = { x: 100, y: 180, width: 100, height: 20 };
    
    // Left edge hit (-75°)
    const leftHit = CollisionDetection.calculatePaddleAngle(110, paddle);
    expect(leftHit).toBeCloseTo(-75, 2);
    
    // Center hit (0°)
    const centerHit = CollisionDetection.calculatePaddleAngle(150, paddle);
    expect(centerHit).toBeCloseTo(0, 2);
    
    // Right edge hit (+75°)
    const rightHit = CollisionDetection.calculatePaddleAngle(190, paddle);
    expect(rightHit).toBeCloseTo(75, 2);
  });
});
```

#### 2.2-UNIT-012: 速度制限境界値テスト
```typescript
describe('Speed Limits Enforcement', () => {
  test('should enforce minimum speed limit', () => {
    const physics = new PhysicsSystem();
    const velocity = new Vector2D(1, 1); // Below 3px/frame
    const limited = physics.enforceLimits(velocity);
    
    expect(limited.magnitude()).toBeCloseTo(3, 1);
  });
  
  test('should enforce maximum speed limit', () => {
    const physics = new PhysicsSystem();
    const velocity = new Vector2D(20, 20); // Above 15px/frame
    const limited = physics.enforceLimits(velocity);
    
    expect(limited.magnitude()).toBeCloseTo(15, 1);
  });
});
```

### P1 Priority Tests (Important Features)

#### 2.2-INT-001: Ball Entity移動統合
```typescript
describe('Ball Entity Integration', () => {
  test('should integrate with PhysicsSystem for movement', async () => {
    const gameEngine = new GameEngine();
    const ball = new Ball({ x: 100, y: 100 });
    gameEngine.addEntity(ball);
    
    // Simulate one frame
    await gameEngine.update(16.67);
    
    expect(ball.position.x).toBeGreaterThan(100);
    expect(ball.previousPosition).toEqual({ x: 100, y: 100 });
  });
});
```

#### 2.2-INT-003: Ball-Paddle衝突統合テスト
```typescript
describe('Ball-Paddle Collision Integration', () => {
  test('should handle collision with angle calculation', async () => {
    const gameEngine = new GameEngine();
    const ball = new Ball({ x: 150, y: 170, velocity: { x: 0, y: 5 } });
    const paddle = new Paddle({ x: 100, y: 180 });
    
    gameEngine.addEntity(ball);
    gameEngine.addEntity(paddle);
    
    await gameEngine.update(16.67);
    
    expect(ball.velocity.y).toBeLessThan(0); // Reflected upward
    expect(Math.abs(ball.velocity.x)).toBeGreaterThan(0); // Angle applied
  });
});
```

#### 2.2-E2E-001: 実際のボール移動視覚確認
```typescript
describe('Ball Movement E2E', () => {
  test('should move ball visually on canvas', async () => {
    render(<GameCanvas />);
    
    const canvas = screen.getByRole('img');
    const startPosition = await getBallPosition(canvas);
    
    // Wait for movement
    await waitFor(() => {
      const currentPosition = getBallPosition(canvas);
      expect(currentPosition.x).not.toBe(startPosition.x);
    }, { timeout: 1000 });
  });
});
```

### P2 Priority Tests (Secondary Features)

#### 2.2-UNIT-010: 重力加速度計算
```typescript
describe('Gravity Physics', () => {
  test('should apply gravity acceleration when enabled', () => {
    const physics = new PhysicsSystem({ gravity: true });
    const velocity = new Vector2D(5, 0);
    
    const updated = physics.applyGravity(velocity, 16.67);
    expect(updated.y).toBeCloseTo(0.164, 3); // 9.8 * 16.67ms
  });
});
```

## Performance Test Specifications

### 60FPS Maintenance Tests
```typescript
describe('Performance Requirements', () => {
  test('should maintain 60FPS with ball physics', async () => {
    const fpsCounter = new FPSCounter();
    const gameEngine = new GameEngine();
    
    // Run for 5 seconds
    for (let i = 0; i < 300; i++) {
      const start = performance.now();
      await gameEngine.update(16.67);
      const end = performance.now();
      
      fpsCounter.recordFrame(end - start);
    }
    
    expect(fpsCounter.averageFPS).toBeGreaterThan(58);
    expect(fpsCounter.minFPS).toBeGreaterThan(55);
  });
});
```

### Memory Efficiency Tests
```typescript
describe('Memory Performance', () => {
  test('should not leak memory during physics calculations', () => {
    const initialMemory = performance.memory.usedJSHeapSize;
    
    // Run intensive physics for 1000 frames
    for (let i = 0; i < 1000; i++) {
      const ball = new Ball({ x: i, y: i });
      ball.update(16.67);
    }
    
    // Force GC
    if (global.gc) global.gc();
    
    const finalMemory = performance.memory.usedJSHeapSize;
    const memoryIncrease = finalMemory - initialMemory;
    
    expect(memoryIncrease).toBeLessThan(1000000); // <1MB increase
  });
});
```

## Recommended Execution Order

### Phase 1: Foundation (P0 Unit Tests)
1. 2.2-UNIT-001: Vector2D速度計算精度
2. 2.2-UNIT-002: 位置更新計算
3. 2.2-UNIT-004: 壁反射角度計算
4. 2.2-UNIT-005: 各壁個別反射
5. 2.2-UNIT-007: Circle-Rectangle衝突検出
6. 2.2-UNIT-008: パドル角度計算
7. 2.2-UNIT-012: 速度制限境界値

### Phase 2: Integration (P0 Integration Tests)
8. 2.2-INT-001: Ball Entity移動統合
9. 2.2-INT-002: PhysicsSystem壁衝突統合
10. 2.2-INT-003: Ball-Paddle衝突統合

### Phase 3: Critical Path (P0 E2E + P1 Tests)
11. 2.2-E2E-001: ボール移動視覚確認
12. 2.2-E2E-002: 壁反射視覚的一貫性
13. P1 Unit/Integration tests

### Phase 4: Secondary Features (P2/P3)
14. Gravity tests
15. UI integration tests
16. Advanced E2E scenarios

## Test Environment Requirements

### Unit Test Environment
- **Framework**: Vitest
- **Mocks**: Canvas 2D API, requestAnimationFrame
- **Precision**: toBeCloseTo() with 2-3 decimal places for physics
- **Performance**: performance.now() mocking for deterministic timing

### Integration Test Environment
- **Framework**: Vitest + React Testing Library
- **Setup**: Game engine initialization, entity lifecycle
- **Mocks**: Sophisticated timing control, EventBus monitoring
- **Validation**: State consistency across systems

### E2E Test Environment
- **Framework**: Playwright
- **Setup**: Full game canvas rendering
- **Validation**: Visual regression testing, actual FPS measurement
- **Browser**: Chrome/Firefox/Safari cross-browser testing

## Success Criteria

### Test Coverage Requirements
- **Overall Coverage**: >90% for physics modules
- **Unit Test Coverage**: >95% for mathematical calculations
- **Integration Coverage**: >85% for system interactions
- **E2E Coverage**: 100% of critical user paths

### Performance Benchmarks
- **60FPS Maintenance**: >95% of frames within 16.67ms
- **Memory Stability**: <10% memory increase over 5-minute session
- **Collision Accuracy**: >99% collision detection precision

### Quality Gates
- **All P0 tests**: Must pass before merge
- **Performance tests**: Must meet FPS/memory requirements
- **Cross-browser E2E**: Must pass in Chrome, Firefox, Safari
- **Mathematical precision**: All physics calculations within 0.1px tolerance

## Test Maintenance Strategy

### Automated Test Execution
- **Pre-commit**: All unit tests (fast feedback)
- **CI Pipeline**: Unit + Integration tests on every PR
- **Nightly**: Full E2E suite including performance tests
- **Release**: Complete test suite + manual verification

### Test Data Management
- **Deterministic inputs**: Fixed test vectors for reproducible results
- **Edge cases**: Boundary value test data sets
- **Performance baselines**: Historical FPS/memory benchmarks
- **Visual references**: Screenshot baselines for E2E visual tests

### Test Evolution
- **Physics accuracy**: Update tests when algorithms improve
- **Performance expectations**: Adjust benchmarks as optimization improves
- **New features**: Extend test coverage for physics enhancements
- **Browser updates**: Maintain compatibility with engine changes